# solver.py -- Z3 solver for challenge.js (Generated)
# Requires: pip install z3-solver
from z3 import Solver, BitVec, BitVecVal, RotateLeft, And, sat

s = Solver()
bytes = [BitVec(f'b{i}', 8) for i in range(32)]

# printable constraint: 0x20 .. 0x7e
for b in bytes:
    s.add(And(b >= BitVecVal(0x20, 8), b <= BitVecVal(0x7e, 8)))
s.add(((bytes[0] ^ bytes[2])) == BitVecVal(42, 8))
s.add(((bytes[1] ^ bytes[5])) == BitVecVal(99, 8))
s.add(((bytes[2] ^ bytes[8])) == BitVecVal(59, 8))
s.add(((bytes[3] ^ bytes[18])) == BitVecVal(65, 8))
s.add(((bytes[4] ^ bytes[23])) == BitVecVal(38, 8))
s.add(((bytes[5] ^ bytes[7])) == BitVecVal(103, 8))
s.add(((bytes[6] ^ bytes[25])) == BitVecVal(80, 8))
s.add(((bytes[7] ^ bytes[29])) == BitVecVal(107, 8))
s.add(((bytes[8] ^ bytes[31])) == BitVecVal(27, 8))
s.add(((bytes[9] ^ bytes[20])) == BitVecVal(0, 8))
s.add(((bytes[10] ^ bytes[18])) == BitVecVal(2, 8))
s.add(((bytes[11] ^ bytes[25])) == BitVecVal(19, 8))
s.add(((bytes[12] ^ bytes[21])) == BitVecVal(31, 8))
s.add(((bytes[13] ^ bytes[27])) == BitVecVal(111, 8))
s.add(((bytes[14] ^ bytes[10])) == BitVecVal(68, 8))
s.add(((bytes[15] ^ bytes[0])) == BitVecVal(60, 8))
s.add(((bytes[16] ^ bytes[10])) == BitVecVal(67, 8))
s.add(((bytes[17] ^ bytes[22])) == BitVecVal(51, 8))
s.add(((bytes[18] ^ bytes[11])) == BitVecVal(2, 8))
s.add(((bytes[19] ^ bytes[0])) == BitVecVal(125, 8))
s.add(((bytes[20] ^ bytes[9])) == BitVecVal(0, 8))
s.add(((bytes[21] ^ bytes[25])) == BitVecVal(15, 8))
s.add(((bytes[22] ^ bytes[1])) == BitVecVal(92, 8))
s.add(((bytes[23] ^ bytes[1])) == BitVecVal(73, 8))
s.add(((bytes[24] ^ bytes[1])) == BitVecVal(111, 8))
s.add(((bytes[25] ^ bytes[14])) == BitVecVal(87, 8))
s.add(((bytes[26] ^ bytes[1])) == BitVecVal(0, 8))
s.add(((bytes[27] ^ bytes[25])) == BitVecVal(83, 8))
s.add(((bytes[28] ^ bytes[19])) == BitVecVal(95, 8))
s.add(((bytes[29] ^ bytes[30])) == BitVecVal(27, 8))
s.add(((bytes[30] ^ bytes[20])) == BitVecVal(112, 8))
s.add(((bytes[31] ^ bytes[26])) == BitVecVal(116, 8))
s.add((RotateLeft(bytes[31], 2) ^ bytes[27]) == BitVecVal(33, 8))
s.add((((bytes[20] + bytes[27] + BitVecVal(48, 8)) )) == BitVecVal(148, 8))
s.add((((bytes[29] * BitVecVal(2, 8) + bytes[23]) )) == BitVecVal(55, 8))
s.add((((bytes[1] + bytes[12] + BitVecVal(13, 8)) )) == BitVecVal(176, 8))
s.add((((bytes[18] * BitVecVal(5, 8) + bytes[27]) )) == BitVecVal(106, 8))
s.add((RotateLeft(bytes[11], 1) ^ bytes[27]) == BitVecVal(208, 8))
s.add((RotateLeft(bytes[20], 2) ^ bytes[5]) == BitVecVal(131, 8))
s.add((((bytes[22] * BitVecVal(7, 8) + bytes[10]) )) == BitVecVal(100, 8))
s.add((RotateLeft(bytes[2], 6) + (bytes[29] ^ bytes[27])) == BitVecVal(136, 8))
s.add((((bytes[19] + bytes[2] + BitVecVal(35, 8)) )) == BitVecVal(186, 8))
s.add((RotateLeft(bytes[23], 1) + (bytes[24] ^ bytes[1])) == BitVecVal(97, 8))
s.add((((bytes[14] + bytes[12] + BitVecVal(30, 8)) )) == BitVecVal(197, 8))
s.add((RotateLeft(bytes[18], 2) ^ bytes[0]) == BitVecVal(135, 8))
s.add((((bytes[23] + bytes[9] + BitVecVal(17, 8)) )) == BitVecVal(190, 8))
s.add((RotateLeft(bytes[25], 3) + (bytes[19] ^ bytes[19])) == BitVecVal(27, 8))
s.add((RotateLeft(bytes[14], 1) ^ bytes[8]) == BitVecVal(55, 8))
s.add((((bytes[21] + bytes[8] + BitVecVal(2, 8)) )) == BitVecVal(205, 8))
s.add((((bytes[28] + bytes[16] + BitVecVal(41, 8)) )) == BitVecVal(200, 8))
s.add((RotateLeft(bytes[16], 3) + (bytes[13] ^ bytes[18])) == BitVecVal(198, 8))
s.add((RotateLeft(bytes[7], 3) ^ bytes[23]) == BitVecVal(216, 8))

if s.check() == sat:
    m = s.model()
    inner = ''.join(chr(m[b].as_long()) for b in bytes)
    print("Recovered inner:", inner)
    print("Flag: CHC{" + inner + "}")
else:
    print("Unsat!")
