# solver.py -- Z3 solver for challenge.js (Generated)
# Requires: pip install z3-solver
from z3 import Solver, BitVec, BitVecVal, RotateLeft, And, sat

s = Solver()
bytes = [BitVec(f'b{i}', 8) for i in range(32)]

# printable constraint: 0x20 .. 0x7e
for b in bytes:
    s.add(And(b >= BitVecVal(0x20, 8), b <= BitVecVal(0x7e, 8)))
s.add(((bytes[0] ^ bytes[2])) == BitVecVal(40, 8))
s.add(((bytes[1] ^ bytes[5])) == BitVecVal(5, 8))
s.add(((bytes[2] ^ bytes[8])) == BitVecVal(62, 8))
s.add(((bytes[3] ^ bytes[18])) == BitVecVal(87, 8))
s.add(((bytes[4] ^ bytes[23])) == BitVecVal(15, 8))
s.add(((bytes[5] ^ bytes[7])) == BitVecVal(51, 8))
s.add(((bytes[6] ^ bytes[25])) == BitVecVal(15, 8))
s.add(((bytes[7] ^ bytes[29])) == BitVecVal(111, 8))
s.add(((bytes[8] ^ bytes[31])) == BitVecVal(99, 8))
s.add(((bytes[9] ^ bytes[20])) == BitVecVal(59, 8))
s.add(((bytes[10] ^ bytes[18])) == BitVecVal(0, 8))
s.add(((bytes[11] ^ bytes[25])) == BitVecVal(70, 8))
s.add(((bytes[12] ^ bytes[21])) == BitVecVal(87, 8))
s.add(((bytes[13] ^ bytes[27])) == BitVecVal(108, 8))
s.add(((bytes[14] ^ bytes[10])) == BitVecVal(60, 8))
s.add(((bytes[15] ^ bytes[0])) == BitVecVal(118, 8))
s.add(((bytes[16] ^ bytes[10])) == BitVecVal(17, 8))
s.add(((bytes[17] ^ bytes[22])) == BitVecVal(0, 8))
s.add(((bytes[18] ^ bytes[11])) == BitVecVal(83, 8))
s.add(((bytes[19] ^ bytes[0])) == BitVecVal(118, 8))
s.add(((bytes[20] ^ bytes[9])) == BitVecVal(59, 8))
s.add(((bytes[21] ^ bytes[25])) == BitVecVal(69, 8))
s.add(((bytes[22] ^ bytes[1])) == BitVecVal(54, 8))
s.add(((bytes[23] ^ bytes[1])) == BitVecVal(10, 8))
s.add(((bytes[24] ^ bytes[1])) == BitVecVal(93, 8))
s.add(((bytes[25] ^ bytes[14])) == BitVecVal(41, 8))
s.add(((bytes[26] ^ bytes[1])) == BitVecVal(90, 8))
s.add(((bytes[27] ^ bytes[25])) == BitVecVal(41, 8))
s.add(((bytes[28] ^ bytes[19])) == BitVecVal(84, 8))
s.add(((bytes[29] ^ bytes[30])) == BitVecVal(94, 8))
s.add(((bytes[30] ^ bytes[20])) == BitVecVal(10, 8))
s.add(((bytes[31] ^ bytes[26])) == BitVecVal(0, 8))
s.add((RotateLeft(bytes[31], 2) ^ bytes[27]) == BitVecVal(147, 8))
s.add((((bytes[20] + bytes[27] + BitVecVal(48, 8)) )) == BitVecVal(243, 8))
s.add((((bytes[29] * BitVecVal(2, 8) + bytes[23]) )) == BitVecVal(195, 8))
s.add((((bytes[1] + bytes[12] + BitVecVal(13, 8)) )) == BitVecVal(218, 8))
s.add((((bytes[18] * BitVecVal(5, 8) + bytes[27]) )) == BitVecVal(78, 8))
s.add((RotateLeft(bytes[11], 1) ^ bytes[27]) == BitVecVal(63, 8))
s.add((RotateLeft(bytes[20], 2) ^ bytes[5]) == BitVecVal(253, 8))
s.add((((bytes[22] * BitVecVal(7, 8) + bytes[10]) )) == BitVecVal(252, 8))
s.add((RotateLeft(bytes[2], 6) + (bytes[29] ^ bytes[27])) == BitVecVal(10, 8))
s.add((((bytes[19] + bytes[2] + BitVecVal(35, 8)) )) == BitVecVal(193, 8))
s.add((RotateLeft(bytes[23], 1) + (bytes[24] ^ bytes[1])) == BitVecVal(35, 8))
s.add((((bytes[14] + bytes[12] + BitVecVal(30, 8)) )) == BitVecVal(225, 8))
s.add((RotateLeft(bytes[18], 2) ^ bytes[0]) == BitVecVal(203, 8))
s.add((((bytes[23] + bytes[9] + BitVecVal(17, 8)) )) == BitVecVal(211, 8))
s.add((RotateLeft(bytes[25], 3) + (bytes[19] ^ bytes[19])) == BitVecVal(179, 8))
s.add((RotateLeft(bytes[14], 1) ^ bytes[8]) == BitVecVal(238, 8))
s.add((((bytes[21] + bytes[8] + BitVecVal(2, 8)) )) == BitVecVal(133, 8))
s.add((((bytes[28] + bytes[16] + BitVecVal(41, 8)) )) == BitVecVal(255, 8))
s.add((RotateLeft(bytes[16], 3) + (bytes[13] ^ bytes[18])) == BitVecVal(227, 8))
s.add((RotateLeft(bytes[7], 3) ^ bytes[23]) == BitVecVal(153, 8))

if s.check() == sat:
    m = s.model()
    inner = ''.join(chr(m[b].as_long()) for b in bytes)
    print("Recovered inner:", inner)
    print("Flag: CHC{" + inner + "}")
else:
    print("Unsat!")
